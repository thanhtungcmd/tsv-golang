// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"
	"tsv-golang/internal/graph/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Authen        func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	HasPermission func(ctx context.Context, obj any, next graphql.Resolver, action string) (res any, err error)
	Validate      func(ctx context.Context, obj any, next graphql.Resolver, required *bool, minLength *int, maxLength *int, pattern *string) (res any, err error)
}

type ComplexityRoot struct {
	Board struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		ProjectID   func(childComplexity int) int
		SortOrder   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
		UseYn       func(childComplexity int) int
	}

	BoardList struct {
		BoardID   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		SortOrder func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UpdatedBy func(childComplexity int) int
		UseYn     func(childComplexity int) int
	}

	LoginResponse struct {
		AccessToken func(childComplexity int) int
		User        func(childComplexity int) int
	}

	Mutation struct {
		ChangePassword  func(childComplexity int, email string, verifyCode string, password string) int
		CreateBoard     func(childComplexity int, input *model.BoardInput) int
		CreateBoardList func(childComplexity int, input *model.BoardListInput) int
		CreateProject   func(childComplexity int, input *model.ProjectInput) int
		CreateUser      func(childComplexity int, input model.UserInput) int
		DeleteBoard     func(childComplexity int, id string) int
		DeleteBoardList func(childComplexity int, id string) int
		DeleteProject   func(childComplexity int, id string) int
		ForgetPassword  func(childComplexity int, email string) int
		UpdateBoard     func(childComplexity int, id string, input model.BoardUpdateInput) int
		UpdateBoardList func(childComplexity int, id string, input model.BoardListUpdateInput) int
		UpdateProject   func(childComplexity int, id string, input model.ProjectUpdateInput) int
		UpdateUser      func(childComplexity int, id string, input model.UserUpdateInput) int
	}

	Project struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		SortOrder   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
		UseYn       func(childComplexity int) int
	}

	Query struct {
		GetBoardByID     func(childComplexity int, id string) int
		GetBoardListByID func(childComplexity int, id string) int
		GetProjectByID   func(childComplexity int, id string) int
		GetUserByID      func(childComplexity int, id string) int
		ListBoard        func(childComplexity int, request *model.ListBoardRequest) int
		ListBoardList    func(childComplexity int, request *model.ListBoardListRequest) int
		ListProject      func(childComplexity int, request *model.ListProjectRequest) int
		ListUsers        func(childComplexity int, request *model.ListUsersRequest) int
		Login            func(childComplexity int, username string, password string) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Email       func(childComplexity int) int
		FirstName   func(childComplexity int) int
		ID          func(childComplexity int) int
		LastName    func(childComplexity int) int
		Password    func(childComplexity int) int
		PhoneNumber func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
		UseYn       func(childComplexity int) int
		Username    func(childComplexity int) int
		VerifyCode  func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Board.createdAt":
		if e.complexity.Board.CreatedAt == nil {
			break
		}

		return e.complexity.Board.CreatedAt(childComplexity), true

	case "Board.createdBy":
		if e.complexity.Board.CreatedBy == nil {
			break
		}

		return e.complexity.Board.CreatedBy(childComplexity), true

	case "Board.description":
		if e.complexity.Board.Description == nil {
			break
		}

		return e.complexity.Board.Description(childComplexity), true

	case "Board.id":
		if e.complexity.Board.ID == nil {
			break
		}

		return e.complexity.Board.ID(childComplexity), true

	case "Board.name":
		if e.complexity.Board.Name == nil {
			break
		}

		return e.complexity.Board.Name(childComplexity), true

	case "Board.project_id":
		if e.complexity.Board.ProjectID == nil {
			break
		}

		return e.complexity.Board.ProjectID(childComplexity), true

	case "Board.sort_order":
		if e.complexity.Board.SortOrder == nil {
			break
		}

		return e.complexity.Board.SortOrder(childComplexity), true

	case "Board.updatedAt":
		if e.complexity.Board.UpdatedAt == nil {
			break
		}

		return e.complexity.Board.UpdatedAt(childComplexity), true

	case "Board.updatedBy":
		if e.complexity.Board.UpdatedBy == nil {
			break
		}

		return e.complexity.Board.UpdatedBy(childComplexity), true

	case "Board.use_yn":
		if e.complexity.Board.UseYn == nil {
			break
		}

		return e.complexity.Board.UseYn(childComplexity), true

	case "BoardList.board_id":
		if e.complexity.BoardList.BoardID == nil {
			break
		}

		return e.complexity.BoardList.BoardID(childComplexity), true

	case "BoardList.createdAt":
		if e.complexity.BoardList.CreatedAt == nil {
			break
		}

		return e.complexity.BoardList.CreatedAt(childComplexity), true

	case "BoardList.createdBy":
		if e.complexity.BoardList.CreatedBy == nil {
			break
		}

		return e.complexity.BoardList.CreatedBy(childComplexity), true

	case "BoardList.id":
		if e.complexity.BoardList.ID == nil {
			break
		}

		return e.complexity.BoardList.ID(childComplexity), true

	case "BoardList.name":
		if e.complexity.BoardList.Name == nil {
			break
		}

		return e.complexity.BoardList.Name(childComplexity), true

	case "BoardList.sort_order":
		if e.complexity.BoardList.SortOrder == nil {
			break
		}

		return e.complexity.BoardList.SortOrder(childComplexity), true

	case "BoardList.updatedAt":
		if e.complexity.BoardList.UpdatedAt == nil {
			break
		}

		return e.complexity.BoardList.UpdatedAt(childComplexity), true

	case "BoardList.updatedBy":
		if e.complexity.BoardList.UpdatedBy == nil {
			break
		}

		return e.complexity.BoardList.UpdatedBy(childComplexity), true

	case "BoardList.use_yn":
		if e.complexity.BoardList.UseYn == nil {
			break
		}

		return e.complexity.BoardList.UseYn(childComplexity), true

	case "LoginResponse.access_token":
		if e.complexity.LoginResponse.AccessToken == nil {
			break
		}

		return e.complexity.LoginResponse.AccessToken(childComplexity), true

	case "LoginResponse.user":
		if e.complexity.LoginResponse.User == nil {
			break
		}

		return e.complexity.LoginResponse.User(childComplexity), true

	case "Mutation.changePassword":
		if e.complexity.Mutation.ChangePassword == nil {
			break
		}

		args, err := ec.field_Mutation_changePassword_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangePassword(childComplexity, args["email"].(string), args["verify_code"].(string), args["password"].(string)), true

	case "Mutation.createBoard":
		if e.complexity.Mutation.CreateBoard == nil {
			break
		}

		args, err := ec.field_Mutation_createBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBoard(childComplexity, args["input"].(*model.BoardInput)), true

	case "Mutation.createBoardList":
		if e.complexity.Mutation.CreateBoardList == nil {
			break
		}

		args, err := ec.field_Mutation_createBoardList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBoardList(childComplexity, args["input"].(*model.BoardListInput)), true

	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["input"].(*model.ProjectInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.UserInput)), true

	case "Mutation.deleteBoard":
		if e.complexity.Mutation.DeleteBoard == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBoard(childComplexity, args["id"].(string)), true

	case "Mutation.deleteBoardList":
		if e.complexity.Mutation.DeleteBoardList == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBoardList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBoardList(childComplexity, args["id"].(string)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["id"].(string)), true

	case "Mutation.forgetPassword":
		if e.complexity.Mutation.ForgetPassword == nil {
			break
		}

		args, err := ec.field_Mutation_forgetPassword_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ForgetPassword(childComplexity, args["email"].(string)), true

	case "Mutation.updateBoard":
		if e.complexity.Mutation.UpdateBoard == nil {
			break
		}

		args, err := ec.field_Mutation_updateBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBoard(childComplexity, args["id"].(string), args["input"].(model.BoardUpdateInput)), true

	case "Mutation.updateBoardList":
		if e.complexity.Mutation.UpdateBoardList == nil {
			break
		}

		args, err := ec.field_Mutation_updateBoardList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBoardList(childComplexity, args["id"].(string), args["input"].(model.BoardListUpdateInput)), true

	case "Mutation.updateProject":
		if e.complexity.Mutation.UpdateProject == nil {
			break
		}

		args, err := ec.field_Mutation_updateProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProject(childComplexity, args["id"].(string), args["input"].(model.ProjectUpdateInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(string), args["input"].(model.UserUpdateInput)), true

	case "Project.createdAt":
		if e.complexity.Project.CreatedAt == nil {
			break
		}

		return e.complexity.Project.CreatedAt(childComplexity), true

	case "Project.createdBy":
		if e.complexity.Project.CreatedBy == nil {
			break
		}

		return e.complexity.Project.CreatedBy(childComplexity), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.sort_order":
		if e.complexity.Project.SortOrder == nil {
			break
		}

		return e.complexity.Project.SortOrder(childComplexity), true

	case "Project.updatedAt":
		if e.complexity.Project.UpdatedAt == nil {
			break
		}

		return e.complexity.Project.UpdatedAt(childComplexity), true

	case "Project.updatedBy":
		if e.complexity.Project.UpdatedBy == nil {
			break
		}

		return e.complexity.Project.UpdatedBy(childComplexity), true

	case "Project.use_yn":
		if e.complexity.Project.UseYn == nil {
			break
		}

		return e.complexity.Project.UseYn(childComplexity), true

	case "Query.getBoardById":
		if e.complexity.Query.GetBoardByID == nil {
			break
		}

		args, err := ec.field_Query_getBoardById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBoardByID(childComplexity, args["id"].(string)), true

	case "Query.getBoardListById":
		if e.complexity.Query.GetBoardListByID == nil {
			break
		}

		args, err := ec.field_Query_getBoardListById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBoardListByID(childComplexity, args["id"].(string)), true

	case "Query.getProjectById":
		if e.complexity.Query.GetProjectByID == nil {
			break
		}

		args, err := ec.field_Query_getProjectById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProjectByID(childComplexity, args["id"].(string)), true

	case "Query.getUserById":
		if e.complexity.Query.GetUserByID == nil {
			break
		}

		args, err := ec.field_Query_getUserById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserByID(childComplexity, args["id"].(string)), true

	case "Query.listBoard":
		if e.complexity.Query.ListBoard == nil {
			break
		}

		args, err := ec.field_Query_listBoard_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListBoard(childComplexity, args["request"].(*model.ListBoardRequest)), true

	case "Query.listBoardList":
		if e.complexity.Query.ListBoardList == nil {
			break
		}

		args, err := ec.field_Query_listBoardList_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListBoardList(childComplexity, args["request"].(*model.ListBoardListRequest)), true

	case "Query.listProject":
		if e.complexity.Query.ListProject == nil {
			break
		}

		args, err := ec.field_Query_listProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListProject(childComplexity, args["request"].(*model.ListProjectRequest)), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		args, err := ec.field_Query_listUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListUsers(childComplexity, args["request"].(*model.ListUsersRequest)), true

	case "Query.login":
		if e.complexity.Query.Login == nil {
			break
		}

		args, err := ec.field_Query_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Login(childComplexity, args["username"].(string), args["password"].(string)), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.created_by":
		if e.complexity.User.CreatedBy == nil {
			break
		}

		return e.complexity.User.CreatedBy(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.first_name":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.last_name":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.phone_number":
		if e.complexity.User.PhoneNumber == nil {
			break
		}

		return e.complexity.User.PhoneNumber(childComplexity), true

	case "User.updated_at":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.updated_by":
		if e.complexity.User.UpdatedBy == nil {
			break
		}

		return e.complexity.User.UpdatedBy(childComplexity), true

	case "User.use_yn":
		if e.complexity.User.UseYn == nil {
			break
		}

		return e.complexity.User.UseYn(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "User.verify_code":
		if e.complexity.User.VerifyCode == nil {
			break
		}

		return e.complexity.User.VerifyCode(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBoardInput,
		ec.unmarshalInputBoardListInput,
		ec.unmarshalInputBoardListUpdateInput,
		ec.unmarshalInputBoardUpdateInput,
		ec.unmarshalInputListBoardListRequest,
		ec.unmarshalInputListBoardRequest,
		ec.unmarshalInputListProjectRequest,
		ec.unmarshalInputListUsersRequest,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputProjectUpdateInput,
		ec.unmarshalInputUserInput,
		ec.unmarshalInputUserUpdateInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "board.graphqls" "board_list.graphqls" "project.graphqls" "schema.graphqls" "user.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "board.graphqls", Input: sourceData("board.graphqls"), BuiltIn: false},
	{Name: "board_list.graphqls", Input: sourceData("board_list.graphqls"), BuiltIn: false},
	{Name: "project.graphqls", Input: sourceData("project.graphqls"), BuiltIn: false},
	{Name: "schema.graphqls", Input: sourceData("schema.graphqls"), BuiltIn: false},
	{Name: "user.graphqls", Input: sourceData("user.graphqls"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
